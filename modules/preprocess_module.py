import os
from .. import settings
import pefile
import peutils
import requests
import hashlib
from shutil import move

def get_AV_percentage_detection(sha1):
    if settings.vt_apikey is not None:
        urlparams = {'apikey': settings.vt_apikey, 'allinfo': 1,
                     'resource': sha1}
        response = requests.get('https://www.virustotal.com/vtapi/v2/file/report', params=urlparams)
        if response.status_code == 200:
            json_response = response.json()
            if 'positives' in json_response:
                return ((int(json_response['positives']) / int(json_response['total'])) * 100)
        return -1
    else:
        print('Missing VirusTotal API key, please insert a valid API key in the config file!')


def get_sha1(filepath):
    BUFF_SIZE = 65536
    sha1 = hashlib.sha1()
    with open(filepath, 'rb')as file:
        while True:
            file_data = file.read(BUFF_SIZE)
            if not file_data:
                break
            sha1.update(file_data)
    return sha1.hexdigest()
def is_packed(filepath):
    signatures = peutils.SignatureDatabase(settings.signatures_filepath)
    pe = pefile.PE(filepath)
    if signatures.match(pe, ep_only=True):
        pe.close()
        return True
    pe.close()
    return False


def get_import_functions(filepath):
    dll_names = []
    pe = pefile.PE(filepath)
    if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
        for entry in pe.DIRECTORY_ENTRY_IMPORT:
            for dll in entry.imports:
                if dll.name is not None:
                    dll = str(dll.name.decode('cp437'))
                    dll_names.append(dll)
    pe.close()
    return dll_names


def is_file_size_valid(filepath):
    return (True if (os.path.getsize(filepath) >= 20480 and os.path.getsize(filepath) <= 3145728) else False)


def is_pe(filepath):
    with open(filepath, 'rb') as file:
        value = file.read(2)
        value = value.decode('cp437')
        if value == 'MZ':
            file.close()
            return True
    return False

def pre_process_test_file():
    for test_file in os.listdir(settings.test_dir):
        try:
            filepath = os.path.join(settings.test_dir, test_file)
            if os.path.isdir(filepath):
                continue
            sha1 = get_sha1(filepath)
            if not (is_pe(filepath)):
                print(test_file + ' is not a valid Windows Portable Executable(PE)!')
                print('Removing file...')
                os.remove(filepath)
                continue
            dllNames = get_import_functions(filepath)
            if test_file is not sha1:
                os.rename(filepath, os.path.join(settings.test_dir, sha1))
                filepath = os.path.join(settings.test_dir, sha1)
            with open(os.path.join(settings.test_dir, 'import_' + sha1), 'w') as write_file:
                for dll in dllNames:
                    write_file.write(dll + '\n')
                print('Function calls for ' + sha1 + ' have been extracted and saved as import_' + sha1)
            print('Moving ' + test_file + ' to test archive...')
            move(filepath, os.path.join(os.path.join(settings.test_dir, 'archive'), test_file))
        except Exception as e:
            print("Error %s" % e)
            with open(settings.error_path, 'a') as errorfile:
                filepath = os.path.join(settings.test_dir, test_file)
                error = 'Error ' + filepath + str(e) + '\n'
                errorfile.write(error)
            os.rename(filepath, os.path.join(settings.test_dir, 'error_' + test_file))
def pre_process_test_file(filename):
    for test_file in os.listdir(settings.test_dir):
        try:
            filepath = os.path.join(settings.test_dir, test_file)
            if os.path.isdir(filepath):
                continue
            if test_file == filename:
                sha1 = get_sha1(filepath)
                if not (is_pe(filepath)):
                    print(test_file + ' is not a valid Windows Portable Executable(PE)!')
                    print('Removing file...')
                    os.remove(filepath)
                    continue
                dllNames = get_import_functions(filepath)
                if test_file is not sha1:
                    os.rename(filepath, os.path.join(settings.test_dir, sha1))
                    filepath = os.path.join(settings.test_dir, sha1)
                with open(os.path.join(settings.test_dir, 'import_' + sha1), 'w') as write_file:
                    for dll in dllNames:
                        write_file.write(dll + '\n')
                    print('Function calls for ' + sha1 + ' have been extracted and saved as import_' + sha1)
                print('Moving ' + test_file + ' to test archive...')
                move(filepath, os.path.join(os.path.join(settings.test_dir, 'archive'), test_file))
                break
        except Exception as e:
            print("Error %s" % e)
            with open(settings.error_path, 'a') as errorfile:
                filepath = os.path.join(settings.test_dir, test_file)
                error = 'Error ' + filepath + str(e) + '\n'
                errorfile.write(error)
            os.rename(filepath, os.path.join(settings.test_dir, 'error_' + test_file))

def pre_process_train_files():
    for dir in settings.list_of_dir:
        print('Pre-processing files in ' + dir)
        for file in os.listdir(dir):
            try:
                filepath = os.path.join(dir, file)
                sha1 = get_sha1(filepath)
                if not (is_pe(filepath) and is_file_size_valid(filepath)):
                    os.remove(filepath)
                    continue
                dllNames = get_import_functions(filepath)
                if len(dllNames) > 10:
                    if dir is settings.samples_malicious_dir:
                        av_detection = get_AV_percentage_detection(sha1)
                        if av_detection == -1 or not (av_detection > 75) or is_packed(filepath):
                            os.remove(filepath)
                            continue
                    else:
                        av_detection = get_AV_percentage_detection(sha1)
                        if av_detection == -1 or not av_detection < 5:
                            os.remove(filepath)
                            continue
                    if file is not sha1:
                        os.rename(filepath, os.path.join(dir, sha1))
                    with open(os.path.join(dir,'import_' + sha1), 'w') as write_file:
                        for dll in dllNames:
                            write_file.write(dll + '\n')
                    print('Function calls for ' + sha1 + ' have been extracted and saved as import_' + sha1)
                else:
                    os.remove(filepath)
                    continue
            except Exception as e:
                print("Error %s" % e)
                with open(settings.error_path, 'a') as errorfile:
                    error = 'Error ' + (os.path.join(dir, file)) + str(e) + '\n'
                    errorfile.write(error)
                os.rename(filepath, os.path.join(dir, 'error_' + file))
